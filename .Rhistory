sigma_CI[2] >= population_sigma) {
result2 <- TRUE
}
return(cbind(result1, result2))
}
# error instance
start_time <- proc.time()
set.seed(2)
simulation()
simulation <- function() {
# generate the seeds and the observed statistic
seeds <- seed_generator()
s_obs <- s_observed()
# run the get_CI function
mean_CI <- get_CI2(alpha, lower_bds, upper_bds, 1, seeds, s_sample, s_obs, tol)
sigma_CI <- get_CI2(alpha, lower_bds, upper_bds, 2, seeds, s_sample, s_obs, tol)
print(mean_CI)
print(sigma_CI)
# result (does the CI contain the true parameter?)
result1 <- FALSE
result2 <- FALSE
if (mean_CI[1] <= population_mu &&
mean_CI[2] >= population_mu) {
result1 <- TRUE
}
if (sigma_CI[1] <= population_sigma &&
sigma_CI[2] >= population_sigma) {
result2 <- TRUE
}
return(cbind(result1, result2))
}
# error instance
start_time <- proc.time()
set.seed(2)
simulation()
source("p_val.R")
get_CI <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# use the p_value function to identify the best starting point for bisection, if there exits any
general_search <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, NULL, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# get_CI with modified objective
get_CI2 <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# identify the best starting point for bisection, if there exits any
general_search <- accept2_helper(alpha, lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$opt_val <= 0) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept2(alpha, updated_lower, updated_upper, seeds, G, s_obs, NULL, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
print("no point in para space")
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# Testing for differentially-private normal (confidence intervals for both mu and sigma)
source("get_CI.R")
reps <- 1000 # total number of simulations # 1000
upper_clamp <- 3
lower_clamp <- 0
n <- 100 # sample size
repro_size <- 200 # number of synthetic samples
eps <- 1 # privacy guarantee parameter
alpha <- .05 # confidence level
tol <- 10^-2
# search region for mean/variance
lower_bds <- c(-5, 0.1)
upper_bds <- c(5,5)
population_mu <- 1 # population mean
population_sigma <- 1 # population sd
# a function that generates a matrix of seeds
seed_generator <- function() {
# generate R*(n+2) i.i.d. standard normals
seeds <- matrix(rnorm(repro_size * (n + 2)), nrow = repro_size, ncol = n + 2)
return(seeds)
}
# a function that computes the private statistics given the seeds and an assumed parameter
s_sample <- function(seeds, theta) {
# generate the raw data points
raw_data <- theta[1] + theta[2]*seeds[, 1:n]
# clamp the raw data
clamped <- pmin(pmax(raw_data, lower_clamp), upper_clamp)
# compute the private statistics
s_mean <- apply(clamped, 1, mean) + (upper_clamp - lower_clamp) / (n * eps) * seeds[, n+1]
s_var <- apply(clamped, 1, var) + (upper_clamp - lower_clamp)^2 / (n * eps) * seeds[, n+2]
return(cbind(s_mean, s_var))
}
# generate an observed statistic given the true parameter
s_observed <- function(){
raw <- population_mu + population_sigma * rnorm(n)
clamped <- pmin(pmax(raw, lower_clamp), upper_clamp)
# compute the private statistics
s_mean <- mean(clamped) + (upper_clamp - lower_clamp) / (n * eps) * rnorm(1)
s_var <- var(clamped) + (upper_clamp - lower_clamp)^2 / (n * eps) * rnorm(1)
return(c(s_mean, s_var))
}
# running a simulation for coverage
simulation <- function() {
# generate the seeds and the observed statistic
seeds <- seed_generator()
s_obs <- s_observed()
# run the get_CI function
mean_CI <- get_CI2(alpha, lower_bds, upper_bds, 1, seeds, s_sample, s_obs, tol)
sigma_CI <- get_CI2(alpha, lower_bds, upper_bds, 2, seeds, s_sample, s_obs, tol)
print(mean_CI)
print(sigma_CI)
# result (does the CI contain the true parameter?)
result1 <- FALSE
result2 <- FALSE
if (mean_CI[1] <= population_mu &&
mean_CI[2] >= population_mu) {
result1 <- TRUE
}
if (sigma_CI[1] <= population_sigma &&
sigma_CI[2] >= population_sigma) {
result2 <- TRUE
}
return(cbind(result1, result2))
}
# error instance
start_time <- proc.time()
set.seed(2)
simulation()
# import this library for Mahalnobis depth
library(ddalpha)
# the Mahalanobis depth (modified to also take in a parameter theta)
# x: each row of x is a vector whose distance we want to compute,
# data: an (R+1) by d matrix containing (R+1) vectors
ma_depth <- function(x, data, theta) {
return(depth.Mahalanobis(x, data))
}
# p_value function
p_value <- function(lower_bds, upper_bds, seeds, G, s_obs, t_init = NULL, T_stat = ma_depth) {
# extract the number of seeds R
R <- dim(seeds)[1]
d <- length(s_obs)
# a function that generate R simulated values using the seeds and G, store s_obs and s_sim in an R+1 by d matrix
s <- function(theta) {
s_values <- rbind(s_obs, G(seeds, theta))
return(s_values)
}
# function that computes and stores the simulated statistics using T_stat
statistics <- function(theta) {
s_matrix <- s(theta)
t_vec <- T_stat(s_matrix, s_matrix, theta)
}
# define the counting function that we feed into optim
count <- function(theta) {
t_values <- statistics(theta)
ct <- sum(t_values[-1] <= t_values[1]) + t_values[1]
return(-ct)
}
# pick the midpoint if t_init is not specified
if (is.null(t_init)) {
t_init <- (lower_bds + upper_bds)/2
}
# call the optim function for minimization
opt <- optim(par = t_init,
fn = count,
method = "L-BFGS-B",
lower = lower_bds,
upper = upper_bds)
m <- -opt$value
theta_hat <- opt$par
# compute the p value and return
p_val <- 1/(R+1) * (min(floor(m), R) + 1)
# compile a list of values to return
results <- list(p_val = p_val,
rank = floor(m)+1,
theta_hat = theta_hat)
return(results)
}
# accept function
accept <- function(alpha, lower_bds, upper_bds, seeds, G, s_obs, t_init = NULL, T_stat = ma_depth) {
# calling the p_value function as a subroutine
p_val <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)$p_val
# return true if we fail to reject
return(p_val > alpha)
}
# helper function for the alternative accept function
accept2_helper <- function(alpha, lower_bds, upper_bds, seeds, G, s_obs, t_init = NULL, T_stat = ma_depth) {
# extract the number of seeds R
R <- dim(seeds)[1]
d <- length(s_obs)
# a function that generate R simulated values using the seeds and G, store s_obs and s_sim in an R+1 by d matrix
s <- function(theta) {
s_values <- rbind(s_obs, G(seeds, theta))
return(s_values)
}
# function that computes and stores the simulated statistics using T_stat
statistics <- function(theta) {
s_matrix <- s(theta)
t_vec <- T_stat(s_matrix, s_matrix, theta)
}
# alternative objective function
new_objective <- function(theta) {
t_values <- statistics(theta)
t_obs <- t_values[1]
# sort the R+1 t_statistics in increasing order
t_values <- sort(t_values)
obj <- t_values[floor(alpha * (R + 1)) + 1] - t_obs
return(obj)
}
# pick the midpoint if t_init is not specified
if (is.null(t_init)) {
t_init <- (lower_bds + upper_bds)/2
}
# minimize the objective function and see if it can be negative
opt <- optim(par = t_init,
fn = new_objective,
method = "L-BFGS-B",
lower = lower_bds,
upper = upper_bds)
print(opt)
opt_value <- opt$value
theta_hat <- opt$par
results <- list(opt_val = opt_value,
theta_hat = theta_hat)
return(results)
}
# accept2 function
accept2 <- function(alpha, lower_bds, upper_bds, seeds, G, s_obs, t_init = NULL, T_stat = ma_depth) {
optim_value <- accept2_helper(alpha, lower_bds, upper_bds, seeds, G, s_obs, t_init = NULL, T_stat = ma_depth)$opt_val
return(optim_value <= 0)
}
source("p_val.R")
get_CI <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# use the p_value function to identify the best starting point for bisection, if there exits any
general_search <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, NULL, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# get_CI with modified objective
get_CI2 <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# identify the best starting point for bisection, if there exits any
general_search <- accept2_helper(alpha, lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$opt_val <= 0) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept2(alpha, updated_lower, updated_upper, seeds, G, s_obs, NULL, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
print("no point in para space")
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# Testing for differentially-private normal (confidence intervals for both mu and sigma)
source("get_CI.R")
reps <- 1000 # total number of simulations # 1000
upper_clamp <- 3
lower_clamp <- 0
n <- 100 # sample size
repro_size <- 200 # number of synthetic samples
eps <- 1 # privacy guarantee parameter
alpha <- .05 # confidence level
tol <- 10^-2
# search region for mean/variance
lower_bds <- c(-5, 0.1)
upper_bds <- c(5,5)
population_mu <- 1 # population mean
population_sigma <- 1 # population sd
# a function that generates a matrix of seeds
seed_generator <- function() {
# generate R*(n+2) i.i.d. standard normals
seeds <- matrix(rnorm(repro_size * (n + 2)), nrow = repro_size, ncol = n + 2)
return(seeds)
}
# a function that computes the private statistics given the seeds and an assumed parameter
s_sample <- function(seeds, theta) {
# generate the raw data points
raw_data <- theta[1] + theta[2]*seeds[, 1:n]
# clamp the raw data
clamped <- pmin(pmax(raw_data, lower_clamp), upper_clamp)
# compute the private statistics
s_mean <- apply(clamped, 1, mean) + (upper_clamp - lower_clamp) / (n * eps) * seeds[, n+1]
s_var <- apply(clamped, 1, var) + (upper_clamp - lower_clamp)^2 / (n * eps) * seeds[, n+2]
return(cbind(s_mean, s_var))
}
# generate an observed statistic given the true parameter
s_observed <- function(){
raw <- population_mu + population_sigma * rnorm(n)
clamped <- pmin(pmax(raw, lower_clamp), upper_clamp)
# compute the private statistics
s_mean <- mean(clamped) + (upper_clamp - lower_clamp) / (n * eps) * rnorm(1)
s_var <- var(clamped) + (upper_clamp - lower_clamp)^2 / (n * eps) * rnorm(1)
return(c(s_mean, s_var))
}
# running a simulation for coverage
simulation <- function() {
# generate the seeds and the observed statistic
seeds <- seed_generator()
s_obs <- s_observed()
# run the get_CI function
mean_CI <- get_CI2(alpha, lower_bds, upper_bds, 1, seeds, s_sample, s_obs, tol)
sigma_CI <- get_CI2(alpha, lower_bds, upper_bds, 2, seeds, s_sample, s_obs, tol)
print(mean_CI)
print(sigma_CI)
# result (does the CI contain the true parameter?)
result1 <- FALSE
result2 <- FALSE
if (mean_CI[1] <= population_mu &&
mean_CI[2] >= population_mu) {
result1 <- TRUE
}
if (sigma_CI[1] <= population_sigma &&
sigma_CI[2] >= population_sigma) {
result2 <- TRUE
}
return(cbind(result1, result2))
}
# error instance
start_time <- proc.time()
set.seed(2)
simulation()
?rnorm
