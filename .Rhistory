# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
source("p_val.R")
get_CI <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# use the p_value function to identify the best starting point for bisection, if there exits any
general_search <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
source("s_sample.R")
source("p_val.R")
source("get_CI.R")
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
get_CI <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# use the p_value function to identify the best starting point for bisection, if there exits any
general_search <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
return(general_search)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
Repro_CI
Repro_CI$p_val >0.05
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
source("p_val.R")
get_CI <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# use the p_value function to identify the best starting point for bisection, if there exits any
general_search <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
get_CI <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# use the p_value function to identify the best starting point for bisection, if there exits any
general_search <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
return(beta_init)
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, T_stat))
}
return(sub_search(0,1))
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
get_CI <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# use the p_value function to identify the best starting point for bisection, if there exits any
general_search <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, T_stat))
}
return(sub_search(0,1))
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
source("p_val.R")
p_value(c(-10, 0.999), c(-1, 1.001), seeds, s_sample, s_obs)
accept(alpha, c(3.1, 0.999), c(10, 1.001), seeds, s_sample, s_obs)
p_value(c(-10, 0.999), c(-1, 1.001), seeds, s_sample, s_obs)
accept(alpha, c(-10, 0.999), c(-1, 1.001), seeds, s_sample, s_obs)
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
traceback()
source("p_val.R")
get_CI <- function(alpha, lower_bds, upper_bds, j, seeds, G, s_obs, tol, t_init = NULL, T_stat = ma_depth) {
# j indicates that we're computing the confidence interval for the jth parameter
# tol represents the allowed tolerance on the boundary of our interval
# T_stat is default to ma_depth as defined in the p_val file
# use the p_value function to identify the best starting point for bisection, if there exits any
general_search <- p_value(lower_bds, upper_bds, seeds, G, s_obs, t_init, T_stat)
if (general_search$p_val > alpha) {
# use the jth coordinate of theta_hat as the starting point for bisection
beta_init <- general_search$theta_hat[j]
# define the sub_search function which returns whether or not a given interval contains a valid point
sub_search <- function(beta_left, beta_right) {
updated_lower <- lower_bds
updated_lower[j] <- beta_left
updated_upper <- upper_bds
updated_upper[j] <- beta_right
# call the accept function to see if (beta_left, beta_right) contains a valid point
return(accept(alpha, updated_lower, updated_upper, seeds, G, s_obs, T_stat))
}
# bisection to find the left boundary
bisect_left <- function(beta_left, beta_right) {
left <- beta_left
right <- beta_right
right_previous <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
right_previous <- right
right <- (left + right)/2
} else {
left <- right
right <- (right + right_previous)/2
}
}
return(left)
}
# bisection to find the right boundary
bisect_right <- function(beta_left, beta_right) {
left <- beta_left
left_previous <- beta_left
right <- beta_right
while (right-left > tol/2) {
if (sub_search(left, right)) {
left_previous <- left
left <- (left + right)/2
} else {
right <- left
left <- (left_previous + left)/2
}
}
return(right)
}
# use bisect_left and bisect_right to compute the left/right boundaries
beta_L <- bisect_left(lower_bds[j], beta_init)
beta_R <- bisect_right(beta_init, upper_bds[j])
return(c(beta_L, beta_R))
} else {
return(NULL) # no point in the parameter space is likely, so return the empty set
}
}
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
source("s_sample.R")
source("p_val.R")
source("get_CI.R")
sample_size <- 100 # sample size
n <- 100 # sample size
R <- 200 # Repro sample size R
alpha <- .05 # significance level
tol <- 10^-4
# population parameters
mu <- 1
sigma <- 1
seeds <- matrix(data = runif(R)) # 200 pre-generated seeds
# generate 50 normal samples based on the population mean and sd
data <- rnorm(n = sample_size,
mean = mu,
sd = sigma)
s_obs <- mean(data)
# unit testing
repro_data <- s_sample(seeds, c(mu, sigma))
plot(density(repro_data), lwd = 2)
p_value(c(-10, 0.999), c(-1, 1.001), seeds, s_sample, s_obs)
accept(alpha, c(-10, 0.999), c(-1, 1.001), seeds, s_sample, s_obs)
# this is the classical way of finding the confidence interval for mu
normal_CI <- function(data, alpha) {
z <- qnorm(1 - alpha/2)
x_bar <- mean(data)
sample_size <- length(data)
half_width <- z/sqrt(sample_size)
interval <- c(x_bar - half_width, x_bar + half_width)
return(interval)
}
classical_CI <- normal_CI(data, alpha)
# this is the confidence interval generated by Repro sampling
Repro_CI <- get_CI(alpha, c(-10, 0.99), c(10, 1.01), 1, seeds, s_sample, s_obs, tol)
Repro_CI
